#!/bin/bash
# shellcheck disable=SC1090,SC1091,SC2034

# Color definitions
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Confirm function
confirm() {
    if [ -n "$ZSH_VERSION" ]; then
        echo -n "${1:-Are you sure? [y/N]} "
        read -rs -k1 response
        echo
    elif [ -n "$BASH_VERSION" ]; then
        read -rp "${1:-Are you sure? [y/N]} " -n1 response
        echo
    else
        echo -n "${1:-Are you sure? [y/N]} "
        read -rs -n1 response
        echo
    fi
    case "$response" in
    [yY])
        true
        ;;
    *)
        false
        ;;
    esac
}

# Homebrew updates
brewup() {
  if command -v brew &>/dev/null; then
    echo -e "${GREEN}Updating Homebrew...${NC}"
    brew update
    echo -e "${GREEN}Installing updates...${NC}"
    brew upgrade
    echo -e "${GREEN}Cleaning up...${NC}"
    brew cleanup
    echo -e "${GREEN}Homebrew update complete!${NC}"
  else
    echo -e "${RED}Error: Homebrew not found. Are you sure it's installed?${NC}"
  fi
}

# General shortcuts
alias bru='brewup'       # Shorter Homebrew updater
alias vscode='code'      # Visual Studio Code
alias powershell='pwsh'  # PowerShell
alias timeout='gtimeout' # timeout

# Function to kill specified types of files
kill_files() {
  local directory="$1"
  local name="$2"

  if [ -z "$directory" ]; then directory="."; fi
  if [ -z "$name" ]; then
    echo "No file type specified."
    return 1
  fi

  find "$directory" -name "$name" -print -delete
}

# Aliases for specific file types
alias killds='kill_files . ".DS_Store"'
alias killjunk='kill_files . "\$RECYCLE.BIN" -o -name "desktop.ini" -o -name "Thumbs.db" -o -name "Icon\?" -o -name ".DS_Store"'
alias killsc='kill_files . "*.sync-conflict-*"'
alias killpkf='kill_files . "*.pkf"'

# Fix compaudit
compfix() {
    if [ "$1" ]; then
        for i in "$@"; do chmod g-w "$i"; done
    else
        echo "Needs at least one argument"
    fi
}

# rsync shortcuts
alias rsync-copy='rsync -avz --progress -h'
alias rsync-move='rsync -avz --progress -h --remove-source-files'
alias rsync-update='rsync -avzu --progress -h'
alias rsync-synchronize='rsync -avzu --delete --progress -h'

# Shortcut to open tmux session 0
[ "$(command -v fzf)" ] || alias tm='tmux new -As0'

if ! command -v eza &>/dev/null; then             # ls aliases (if eza is not installed)
    alias ls='ls --color=auto' # add color to ls
    alias ll='ls -l'           # list files as a long list
    alias l='ls -lFh'          # list files as a long list, show size, type, human-readable
    alias la='ls -lAFh'        # list almost all files as a long list show size, type, human-readable
    alias lr='ls -tRFh'        # list files recursively sorted by date, show type, human-readable
    alias lt='ls -ltFh'        # list files as a long list sorted by date, show type, human-readable
    alias ldot='ls -ld .*'     # list dot files as a long list
    alias lS='ls -1FSsh'       # list files showing only size and name sorted by size
    alias lart='ls -1Fcart'    # list all files sorted in reverse of create/modification time (oldest first)
    alias lrt='ls -1Fcrt'      # list files sorted in reverse of create/modification time(oldest first)
    alias lsr='ls -lARFh'      # list all files and directories recursively
    alias lsn='ls -1'          # list files and directories in a single column
else                                              # if eza is installed, use that instead of ls
    alias ls='eza -bg'                            # list files with grid view and block size
    alias ll='eza -laFb'                          # list all files in long format, classify file type, show block size
    alias l='eza -1'                              # list files in single column format
    alias li='eza -1 --icons'                     # list files in single column format with icons for file type
    alias la='eza -1a'                            # list all files in single column format
    alias lt='eza -T --level=2'                   # display tree view with 2 levels deep
    alias l2='eza -T --level=2'                   # display tree view with 2 levels deep
    alias lt2='eza -T --level=2'                  # display tree view with 2 levels deep
    alias l3='eza -T --level=3'                   # display tree view with 3 levels deep
    alias lt3='eza -T --level=3'                  # display tree view with 3 levels deep
    alias lat='eza -aT --level=2'                 # display all files in tree view with 2 levels deep
    alias la2='eza -aT --level=2'                 # display all files in tree view with 2 levels deep
    alias lat2='eza -aT --level=2'                # display all files in tree view with 2 levels deep
    alias la3='eza -aT --level=3'                 # display all files in tree view with 3 levels deep
    alias lat3='eza -aT --level=3'                # display all files in tree view with 3 levels deep
    alias lf='eza -1 --group-directories-first'   # list files in single column format, directories displayed first
    alias lfa='eza -1a --group-directories-first' # list all files in single column format, directories displayed first
fi

# if bat is installed, use that instead of cat
if command -v bat &>/dev/null; then
    alias cat='bat -p'
fi

# head / tail / grep / miscellaneous shortcuts
alias h='history'                                               # show the command history
alias hs='history 0 | grep'                                     # search the command history
alias hsi='history 0 | grep -i'                                 # search the command history (case-insensitive)
alias grep='grep --color'                                       # grep with color output for matches
alias sgrep='grep -R -n -H -C 5 --exclude-dir={.git,.svn,CVS} ' # recursive grep in files with line numbers, file names, 5 lines of context
alias t='tail -f'                                               # follow the end of a file in real time
alias H='| head'                                                # pipe to head command (show first few lines of input)
alias T='| tail'                                                # pipe to tail command (show last few lines of input)
alias G='| grep'                                                # pipe to grep command (search input)
alias L="| less"                                                # pipe to less command (paged output)
alias M="| most"                                                # pipe to most command (paged output)
alias LL="2>&1 | less"                                          # redirect standard error and standard output to less command
alias CA="2>&1 | cat -A"                                        # redirect standard error and standard output to cat -A command (show all special characters)
alias NE="2> /dev/null"                                         # redirect standard error to null (discard error output)
alias NUL="> /dev/null 2>&1"                                    # redirect both standard output and standard error to null (discard all output)
alias P="2>&1| pygmentize -l pytb"                              # redirect standard error and standard output to pygmentize command (syntax highlighting for python traceback)

# searching and sizing
alias dud='du -d 1 -h'                          # display the size of files at depth 1 in current location in human-readable form
alias duds='du -d 1 -h | sort -hr'              # same as above but sorted by size
[ "$(command -v duf)" ] || alias duf='du -sh *' # display the size of files in current location in human-readable form
alias ffil='find . -type f -name'               # find a file with the given name
alias fdir='find . -type d -name'               # find a file with the given name

# Use fzf to clear from zsh history
alias histfzf='history -w; cat .zsh_history | fzf > /tmp/rm; grep -vxFf /tmp/rm .zsh_history > .new_zsh_history; mv .new_zsh_history .zsh_history; rm /tmp/rm; history -r'

# SSH shortcuts
alias ska='eval "$(ssh-agent -s)"'       # start SSH agent
alias skm='ssh-add --apple-use-keychain' # add to agent (Mac)
alias skl='ssh-add'                      # add to agent (Linux)
alias sshk='kitty +kitten ssh'           # connect with kitty

# Remove line from ~/.ssh/known_hosts
rmknown() {
    if [ "$1" ]; then
        re='^[0-9]+$'
        if ! [[ $1 =~ $re ]]; then
            echo "Error: Not a number" >&2
        else
            gsed -i "$1"d ~/.ssh/known_hosts
            echo "Removed line $1"
        fi
    else
        echo "Error: No line number specified" >&2
    fi
}

# mosh
function mosh() {
    case "$1" in
    "calufrax" | "defiant")
        shift
        mosh --server=/opt/homebrew/bin/mosh-server "$@"
        ;;
    *)
        command mosh "$@"
        ;;
    esac
}

if [[ "$(uname)" == "Darwin" ]]; then
  source "$HOME/.config/shell/aliases_mac"
elif [[ "$(uname)" == "Linux" ]]; then
  source "$HOME/.config/shell/aliases_linux"
fi

# Environment variable to make Docker builds display output again
export BUILDKIT_PROGRESS=plain

# Alias for devpi
alias devpi="devpi --clientdir ~/.devpi"

# Alias to clean Python junk files
alias pyclean='find . -type d -name "__pycache__" -exec rm -rf {} + && \
               find . -type d -name "*.egg-info" -exec rm -rf {} + && \
               find . -type d -name ".idea" -exec rm -rf {} + && \
               find . -type d -name ".mypy_cache" -exec rm -rf {} + && \
               find . -type d -name ".pytest_cache" -exec rm -rf {} + && \
               find . -type d -name ".ruff_cache" -exec rm -rf {} + && \
               find . -type d -name ".tox" -exec rm -rf {} + && \
               find . -type d -name ".coverage" -exec rm -rf {} + && \
               find . -type f -name ".coverage" -delete && \
               find . -type f -name "*.pyc" -delete'

# Undo a version bump (done via dsbump script)
function undo_bump() {
    # Define colors
    GREEN='\033[0;32m'
    RED='\033[0;31m'
    NC='\033[0m' # No Color

    # Get the most recent tag
    if ! LATEST_TAG=$(git describe --tags --abbrev=0); then
        echo -e "${RED}Error: Could not find any tags${NC}"
        return 1
    fi

    # Delete local tag
    echo -e "${GREEN}Removing local tag $LATEST_TAG...${NC}"
    if ! git tag -d "$LATEST_TAG"; then
        echo -e "${RED}Error: Failed to delete local tag${NC}"
        return 1
    fi

    # Delete remote tag
    echo -e "${GREEN}Removing remote tag $LATEST_TAG...${NC}"
    if ! git push origin --delete "$LATEST_TAG"; then
        echo -e "${RED}Error: Failed to delete remote tag${NC}"
        return 1
    fi

    # Reset HEAD to previous commit
    echo -e "${GREEN}Removing last commit...${NC}"
    if ! git reset --hard HEAD~1; then
        echo -e "${RED}Error: Failed to reset to previous commit${NC}"
        return 1
    fi

    # Force push changes
    echo -e "${GREEN}Force pushing changes...${NC}"
    if ! git push --force; then
        echo -e "${RED}Error: Failed to force push${NC}"
        return 1
    fi

    echo -e "${GREEN}Successfully undid version bump!${NC}"
}

# Install development versions of dsbin and dsbase
dsdev() {
    # Store the original directory
    original_dir=$(pwd)

    # Install local version of dsbin
    cd ~/Developer/dannystewart/dsbin || return
    pip install -e .

    # Install local version of dsbase (to override what's installed by dsbin)
    cd ~/Developer/dannystewart/dsbase || return
    pip install -e .

    # Return to original directory
    cd "$original_dir" || return
}

# Function to uninstall and reinstall multiple packages with pip
function pip-reinstall() {
    if [ $# -eq 0 ]; then
        echo "Usage: pip-reinstall package_name [package_name2 ...]"
        return 1
    fi

    for package_name in "$@"; do
        # Uninstall the package
        echo "Uninstalling $package_name..."
        pip uninstall -y "$package_name"
    done

    for package_name in "$@"; do
        # Reinstall the package
        echo "Reinstalling $package_name..."
        pip install "$package_name"
    done
}

# Function to add a Git repo version to Poetry
function poetry-repo() {
# Parse the argument to extract package name and version/tag/commit
    local full_arg="$1"
    local package
    local version="latest"

    if [[ "$full_arg" == *@* ]]; then
        package="${full_arg%@*}"
        version="${full_arg#*@}"
    else
        package="$full_arg"
    fi

    if [ -z "$package" ]; then
        echo "Usage: poetry-add-repo package_name[@version|tag|commit]"
        return 1
    fi

    local repo_url="https://github.com/dannystewart/${package}.git"

    # Check if the repo exists
    if ! git ls-remote --exit-code "$repo_url" &>/dev/null; then
        echo "Error: Repository $repo_url does not exist or is not accessible"
        return 1
    fi

    local ref

    if [ "$version" = "latest" ]; then
        # Get the latest commit hash and shorten it to 7 characters
        ref=$(git ls-remote "$repo_url" HEAD | cut -f1 | cut -c1-7)
        echo "Using latest commit: $ref"
    elif [[ "$version" == v* ]] || [[ "$version" =~ ^[0-9] ]]; then
        # Try to find as a tag first
        local tag_exists=false

        # Check if the exact tag exists
        if git ls-remote --tags "$repo_url" "refs/tags/$version" | grep -q "refs/tags/$version"; then
            tag_exists=true
            ref="$version"
        # If version doesn't start with v, try with v prefix
        elif [[ "$version" =~ ^[0-9] ]] && git ls-remote --tags "$repo_url" "refs/tags/v$version" | grep -q "refs/tags/v$version"; then
            tag_exists=true
            ref="v$version"
        fi

        if ! $tag_exists; then
            # If it looks like a version but tag doesn't exist, it could be a commit hash that happens to start with numbers
            ref="$version"
        fi
    else
        # Assume it's a commit hash
        ref="$version"
        echo "Using commit: $ref"
    fi

    if [ -z "$ref" ]; then
        echo "Error: Could not determine reference to use"
        return 1
    fi

    echo "Adding $package from $repo_url at $ref"
    poetry add "git+$repo_url@$ref"
}

# Remove Fork's backup branches
alias rmbb='git branch | grep "backup/" | xargs git branch -D'

# Update all the things
uatt() {
  local updated=false
  local os_type
  os_type=$(uname -s)

  echo -e "${BLUE}Updating all the things...${NC}"

  if [ "$os_type" = "Linux" ]; then
    if command -v apt-get &>/dev/null; then
      aptup
      updated=true
    elif command -v pacman &>/dev/null; then
      pacup
      updated=true
    elif command -v dnf &>/dev/null; then
      dnfup
      updated=true
    elif command -v softwareupdate &>/dev/null; then
      sudo softwareupdate --background
      updated=true
    else
      echo -e "${RED}No supported Linux package manager found (apt, pacman, dnf).${NC}"
    fi
  elif [ "$os_type" != "Darwin" ]; then
    echo -e "${RED}Unsupported operating system: $os_type${NC}"
  fi

  if command -v brew &>/dev/null; then
    brewup
    updated=true
  fi

  if command -v chezmoi &>/dev/null; then
    echo -e "${GREEN}Updating Chezmoi...${NC}"
    chezmoi update
    echo -e "${GREEN}Chezmoi updated!${NC}"
    updated=true
  fi

  if [ "$updated" = false ]; then
    echo -e "${RED}No updates were performed. Unsupported system or missing tools.${NC}"
  else
    echo -e "${BLUE}All updates complete!${NC}"
  fi
}

# Update pip packages
function pip() {
  if [ "$1" = "update" ]; then
    printf "\033[0;36m==> \033[1;36mUpdating pip packages...\033[0m\n"
    # shellcheck disable=SC2046
    command pip install -U pip $(command pip freeze | grep -v '@' | cut -d'=' -f1) 2>&1 |
      grep -v "Requirement already satisfied:" |
      grep -v -E "dulwich|keyring"
    printf "\033[0;32m==> \033[1;32mUpdates complete!\033[0m\n"
  else
    command pip "$@"
  fi
}

# Install DS packages from PyPI or GitHub
dsinstall() {
  local package=${1:-dsbin} # Default to dsbin if no argument

  echo -e "${GREEN}Installing ${package}...${NC}"
  pip uninstall -y "${package}" 2>/dev/null

  echo -e "${GREEN}Attempting to install ${package} from PyPI...${NC}"
  if pip install -U "${package}" 2>/dev/null; then
    echo -e "${GREEN}${package} installed successfully from PyPI${NC}"
  else
    echo -e "${YELLOW}Package not found on PyPI, installing from GitHub...${NC}"
    pip install -U "git+ssh://git@github.com/dannystewart/${package}.git" || {
      echo "Failed to install ${package}"
      return 1
    }
    echo -e "${GREEN}${package} installed successfully from GitHub${NC}"
  fi
}

# Aliases to install packages directly
alias dsbin='dsinstall dsbin'
alias dsbase='dsinstall dsbase'
alias dsuninstall='pip uninstall -y dsbase dsbin dsupdater evremixes iplooker pybumper'
alias dsreinstall='pip install dsbase dsbin dsupdater evremixes iplooker pybumper'
