#!/bin/bash
# shellcheck disable=SC1090,SC1091

# Alias for devpi
alias devpi="devpi --clientdir ~/.devpi"

# Alias to clean Python junk files
alias pyclean='find . -type d -name "__pycache__" -exec rm -rf {} + && \
               find . -type d -name "*.egg-info" -exec rm -rf {} + && \
               find . -type d -name ".idea" -exec rm -rf {} + && \
               find . -type d -name ".mypy_cache" -exec rm -rf {} + && \
               find . -type d -name ".pytest_cache" -exec rm -rf {} + && \
               find . -type d -name ".ruff_cache" -exec rm -rf {} + && \
               find . -type d -name ".tox" -exec rm -rf {} + && \
               find . -type d -name ".coverage" -exec rm -rf {} + && \
               find . -type f -name ".coverage" -delete && \
               find . -type f -name "*.pyc" -delete'

# Undo a version bump (done via dsbump script)
function undo_bump() {
    # Define colors
    GREEN='\033[0;32m'
    RED='\033[0;31m'
    NC='\033[0m' # No Color

    # Get the most recent tag
    if ! LATEST_TAG=$(git describe --tags --abbrev=0); then
        echo -e "${RED}Error: Could not find any tags${NC}"
        return 1
    fi

    # Delete local tag
    echo -e "${GREEN}Removing local tag $LATEST_TAG...${NC}"
    if ! git tag -d "$LATEST_TAG"; then
        echo -e "${RED}Error: Failed to delete local tag${NC}"
        return 1
    fi

    # Delete remote tag
    echo -e "${GREEN}Removing remote tag $LATEST_TAG...${NC}"
    if ! git push origin --delete "$LATEST_TAG"; then
        echo -e "${RED}Error: Failed to delete remote tag${NC}"
        return 1
    fi

    # Reset HEAD to previous commit
    echo -e "${GREEN}Removing last commit...${NC}"
    if ! git reset --hard HEAD~1; then
        echo -e "${RED}Error: Failed to reset to previous commit${NC}"
        return 1
    fi

    # Force push changes
    echo -e "${GREEN}Force pushing changes...${NC}"
    if ! git push --force; then
        echo -e "${RED}Error: Failed to force push${NC}"
        return 1
    fi

    echo -e "${GREEN}Successfully undid version bump!${NC}"
}

# Install development versions of dsbin and dsbase
dsdev() {
    # Store the original directory
    original_dir=$(pwd)

    # Install local version of dsbin
    cd ~/Developer/dannystewart/dsbin || return
    pip install -e .

    # Install local version of dsbase (to override what's installed by dsbin)
    cd ~/Developer/dannystewart/dsbase || return
    pip install -e .

    # Return to original directory
    cd "$original_dir" || return
}

# Function to uninstall and reinstall multiple packages with pip
function pip-reinstall() {
    if [ $# -eq 0 ]; then
        echo "Usage: pip-reinstall package_name [package_name2 ...]"
        return 1
    fi

    for package_name in "$@"; do
        # Uninstall the package
        echo "Uninstalling $package_name..."
        pip uninstall -y "$package_name"
    done

    for package_name in "$@"; do
        # Reinstall the package
        echo "Reinstalling $package_name..."
        pip install "$package_name"
    done
}

# Function to add a Git repo version to Poetry
function poetry-repo() {
# Parse the argument to extract package name and version/tag/commit
    local full_arg="$1"
    local package
    local version="latest"

    if [[ "$full_arg" == *@* ]]; then
        package="${full_arg%@*}"
        version="${full_arg#*@}"
    else
        package="$full_arg"
    fi

    if [ -z "$package" ]; then
        echo "Usage: poetry-add-repo package_name[@version|tag|commit]"
        return 1
    fi

    local repo_url="https://github.com/dannystewart/${package}.git"

    # Check if the repo exists
    if ! git ls-remote --exit-code "$repo_url" &>/dev/null; then
        echo "Error: Repository $repo_url does not exist or is not accessible"
        return 1
    fi

    local ref

    if [ "$version" = "latest" ]; then
        # Get the latest commit hash and shorten it to 7 characters
        ref=$(git ls-remote "$repo_url" HEAD | cut -f1 | cut -c1-7)
        echo "Using latest commit: $ref"
    elif [[ "$version" == v* ]] || [[ "$version" =~ ^[0-9] ]]; then
        # Try to find as a tag first
        local tag_exists=false

        # Check if the exact tag exists
        if git ls-remote --tags "$repo_url" "refs/tags/$version" | grep -q "refs/tags/$version"; then
            tag_exists=true
            ref="$version"
        # If version doesn't start with v, try with v prefix
        elif [[ "$version" =~ ^[0-9] ]] && git ls-remote --tags "$repo_url" "refs/tags/v$version" | grep -q "refs/tags/v$version"; then
            tag_exists=true
            ref="v$version"
        fi

        if ! $tag_exists; then
            # If it looks like a version but tag doesn't exist, it could be a commit hash that happens to start with numbers
            ref="$version"
        fi
    else
        # Assume it's a commit hash
        ref="$version"
        echo "Using commit: $ref"
    fi

    if [ -z "$ref" ]; then
        echo "Error: Could not determine reference to use"
        return 1
    fi

    echo "Adding $package from $repo_url at $ref"
    poetry add "git+$repo_url@$ref"
}

# Remove Fork's backup branches
alias rmbb='git branch | grep "backup/" | xargs git branch -D'
